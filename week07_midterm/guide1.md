在过去的几周里，我已经完全从cursor切换到了cloud code，并且学到了很多让我的cloud code变得非常高效的技巧。今天我会带你们了解我是如何使用coco的，我是如何实现类似英雄式的以基于规范驱动的事件处理流程的，还有一些关于我如何使用hooks自定义命令等功能的技巧和实际案例，以及让我自己变得更加高效的一系列小贴士。那么话不多说，我们马上开始吧。

首先你需要安装这个cloud code的扩展，这样你就可以将它深度集成到你当前的开发环境中，比如cursor VS code和Winsor。现在我可以点击这个运行cloud code code按钮，它会自动在我当前开发环境中打开CLOUD code，在右下角你应该能看到它正在检测我当前所在的具体文件。如果我选中一些代码行，它也会自动检测到，你依然可以在这里使用。终端只需要输入ID就可以选择你想要连接的特定开发环境。

接下来在你做任何操作之前，第一步应该是运行这个innit命令行。这个Internet命令行的作用是让cloud开始分析你的代码库，了解已经设置了哪些内容，以及你应该使用哪些依赖和组件。它还会请求你的许可来执行某些操作。对于像CD这样的命令我根本不在意，我通常会直接点击，始终自动批准。你会看到这个操作会被自动保存为权限设置。

我知道有些人其实希望CLODCO总是自动运行工具，其实你也可以这样设置，你可以选择这种极其危险的权限设置，这样做会让你看到它正在绕过所有权限检查，所以现在这个工具会直接请求你的许可。
不过我其实并不推荐这样做，因为根据我的经验，CLOCO的用户体验有一个很大的优势，就是它能让你更好的与云端交互。接下来我会解释我的意思。

好的，所以在扫描完成后，它会尝试创建一个cloud md文件。如果你在使用cursor，这基本上就是你的Curr规则。如果我们点进去看你会发现它会自动生成类似于文本摘要的内容，比如运行和构建命令架构，项目结构以及所有有用的信息。所以这为cloud d提供了一个非常好的基础，可以在这个仓库之上继续开发新的功能。而这个cloud MD正如我之前提到的，基本上就是curse的规则。唯一的区别在于在closer中这些规则是以更程序化的方式注入的。但对于cloud来说，这要简单的多。基本上每次运行时，你在这里定义的这段文本都会被附加到系统消息的最前面。我知道有很多人有各种各样的curser规则用来提升工作流程。对我来说通常都很简单，我会加的一个提示词就是这个计划与回顾模式。这基本上是告诉CLOROOD，在我们开始一个项目之前，总是先进入计划模式，先制定一个计划。对于这个计划，我们希望将其保存到this cloud task task name medley，这样我们之后可以追踪进度。在这个任务中我们应该把它拆分成不同的子任务。当cloud o在执行任务时，他也应该随着进展不断更新计划，并把它所做的内容追加到文档中。这非常有用，因为几乎总是更好的直接告诉CLO，CO你到底想要什么。这其实也有点类似于亚马逊最新的Kerr工作流，他们称之为规范驱动开发spec driven development。其实现方式也很相似，它会让你梳理需求，同时也会让你梳理架构设计，提出基本上这就是同一件事。当然你也可以像kiro那样深入把这三步流程细分开来。但我发现通常只做一种产品需求文档PRD就已经足够有效了。所以我我会把这个保存下来。现在我们可以让Clark ke开始实现我们的功能了。通常我做的第一件事就是制定一个计划，所以我会输入提示，我们正在构建一个漂亮的在线身份证前端，请帮我拆解成关键组件，并最终将它们组合在一起。

这里我要按下shift tap，它首先会进入自动接收编辑模式，但你需要再次shift tap进入计划模式。所以这个计划模式是一个非常非常有用的功能。当智能体处于计划模式时，它会有一个特殊的系统提示，并且对工具的访问也会受到限制。所以它会专注于做一些事情，比如进行网页搜索，以了解最新的技术文档或资料。同时规划架构最后还会生成最终报告，而且这个规划过程有时候会花费一些时间。对于任何稍微复杂一点的功能，我都会先用这个计划模式来回几次，把计划和CLOCO的对齐。只有在这之后我才会开始实现这个功能。所以在这里你会看到它正在显示任务。当你看到任务时，基本上就意味着CLOCKOD正在调用一个专门负责规划和调研的子智能体。

所以默认情况下CLOCO code拥有17种不同的工具。它可以执行注入运行、命令行读取和查找文件、文件操作以及网页搜索等操作。而这个任务二基本上意味着它会为关键词和文件搜索启动一个新的智能体当CLOCCO的智能体。调用这个任务二时，它实际上是在创建另一个智能体。这个智能体拥有几乎所有工具，除了那些与规划相关的工具，比如task studio。这个智能体会从副智能体那里接收到明确定义的任务，执行一系列操作，最后给出。以下是调查结果，只有最后一部分，也就是调查结果的总结会被发送回负极CLOCOO的智能体。而这就是他们用来真正节省副智能体令牌消耗的一种方法，否则主智能体可能会被各种内容淹没。了解了这一点，你实际上可以更好的利用这个任务。2、例如你实际上可以提示CLOCCOD使用任务二来设置多个并行智能体，同时执行不同的任务。另外如果你已经知道某个任务需要读取非常大的文件，也可以尝试提示CLO code只用任务二来完成，这样可以大大节省主智能体的令牌消耗。现在它已经完成了规划，并带回了一份关于其他布局系统应该是什么样子的计划。比如文件资源管理器，这很合理。对于代码编辑器组件，他决定使用现有的库，然后会将任务分解为不同的阶段，第一阶段只是安装所有内容，第二阶段则实现文件资源管理器、代码编辑器、终端集成以及一些高级功能，还有项目目录的规划。所以这是一个相当不错的计划，显然我可以继续规划，但在这里我也可以让他开始执行这个计划。接下来他会在CLUD tasks中创建这个详细的实施计划。我会点击是这样，他就会创建这个任务文件夹，并为这个在线ID前端生成一个详细的计划和任务。现在我可以让你来做第一阶段，我们会根据第一阶段的需求创建一个待办事项。在它运行的时候，我想快速谈一下这个待办事项。我很好奇CARRRROD到底是如何处理这个待办事项。他们把处理交给了不同的，比如规划代理，让他专门制定计划，然后通过编程方式让一个代理一个接一个地完成任务嘛。所以我做了一些调查，我发现entrer y团队实际上采用了最简单的设置方式，但效果却非常好。还有一个叫做TORIE的工具，你会看到他的描述基本上是使用这个工具来创建和管理你的结构化任务列表。他们有一个非常具体的提示，说明什么时候该用这个工具，什么时候不该用，还有一些事例。所以每次代理运行这个工具时，它都会尝试生成这个待办事项，然后代办事项都会有内容ID优先级和状态就是这么简单。所以现在如果我们回到这里，它已经完成了所有的待办事项。我们也回到我们的文档，添加了关于他实际做了什么的详细信息。所以他这个标记为已完成，并且记录了他所做的所有事情，很酷。所以它实现了这个组件带有文件资源管理器，并且可以调整大小。还有终端，我也可以添加多个不同的终端。不错，很明显你可以看到我可以继续往下做。因为它已经有了整体计划的追踪，所以每次它只需要专注于某一个具体的工作部分。如果有任何时候计划发生变化，我们只需要提示它更新这个文档就可以了。所以这就形成了一个以文档或规范为中心的CLOCCO的工作流。但CLOCO真正酷的地方在于你可以非常深入的自定义clo KO。所以有一个非常有趣的功能叫做hooks gosa hook，是一个允许你在cloud de执行某些操作时，以编程方式定义要发生的事情的功能。我最常用也是最基础的hook之一就是这个stop hook。所以我我可以在这里一个一个规则，当cloud code de停止时，也就是它完成一个任务时，它会尝试运行这个命令。这个命令基本上会播放系统提示音来通知我任务已经完成。所以有了这个功能，如果我只是向cloud发送一条消息，任务完成后，它就会播放一个提示音，就基本上就是hook的一个简单概念。但有趣的是这里的自定义其实可以做的非常任入CLOUDOD，允许你在某个工具运行之前或之后，或者当用户尝试向cloud code de发送新消息时，定义要执行的操作。这样你就可以注入一些额外的上下文信息，同样也可以在cloud尝试压缩对话历史或者子代理完成任务时进行自定义。现在这里有一个更复杂的例子，我发现它实际上非常有用，我可以定义这个post to hook MOLLOLOOD运行edit multi dt t ride工具后。也就是每次修改或创建新文件后，它都会运行我在这里定义的这个名为type checked Python文件。这是我在cursor上最怀念的一个功能，就是cursor里有自动关联的错误检测，这提供了非常有用的上下文信息。RNRRR能在你运行代码之前就捕捉到这些错误，并主动修复问题。那cloud并没有这个功能，这个hook基本上可以直接获取内容功能。而这个Python文件里内容可能看起来有点复杂，但我会很快给你解释一下它的含义。首先我们会尝试获取输入数据，每个hook都带有一组不同的输入，你可以使用这些输入。比如对于posto U输入，它会自动提供一个你可以用的数据表。然后我们代代理工具生成了什么输入，以及工具的输入输入什么。在这个例子中我们想要获取文件，这样我们就能知道代理刚刚创建或修改了哪个文件。然后我们会获取文件路径。如果这个文件的扩展名是TS或TSX，也就是TypeScript文件，我们就会运行类型检查。如果类型检查失败，这部分就是我们可以把反馈发送回CLOCOD的地方。所以你会进行打印文件，会输出到系统的标准错误。这里我把退出码定义为二，所以退出码二表示这是一个阻塞性错误。标准错误会被反馈给class code，这样它就可以用来决定下一步的操作。但你也可以定义其他退出码，这些退出码同样会把消息发送回CLOLOLOUD，但不会阻止它继续执行下一个操作。所以通过这个钩子，如果cloud code在有类型错误的文件上生成内容，它会自动调用这个脚本，并在有类型错误时返回一条错误信息，这样cloud code就可以主动尝试修复这个问题，这就是钩子的工作原理，而且这里有很多潜力口型。我还包含了一些我在AI build cloud中经常用到的常见钩子，你可以直接去获取。另一方面CLOLOLOD还具备命令功能，他们会提供一系列预定义命令，比如检查成本设置MCP内存模型，甚至还有审查PR的命令。但他们也允许你自定义斜杠命令，比如我可以在cloud d下创建一个commons文件夹，然后新建一个叫Joe command的文件，并用全大写写一个笑话。完成这些后，我就可以输入斜杠并搜索joke，然后我在这里定义的这个命令就会显示出来。如果我点击它，你在这个命令里定义的内容基本上会作为命令词发送给CLOCOD。然后它就会根据你在那里定义的规则开始执行相应的行为。我还有另一段视频讲解了我预设的不同命令，这些命令可以帮助你从截图中提取特定的样式，还能让CLOUD code进入设计模式，以便设计移动端的不同UI迭代。你甚至可以用一个命令让cloud code设置多个不同的git工作，数让子代理并行工作。如果你想了解更多，可以去看看这段视频。最近我发现有一个非常实用的软件包叫做super club。这是一个开源软件包，内置了许多他们预设和开发的命令。比如我可以使用斜杠命令c analyze就会触发该命令，让cloud进入更深层次的代码分析模式。它会创建一个待办事项列表，遍历整个代码库，并给出一种架构性的评审。还有其他实用的功能，比如你可以运行工作流，查看PRD文档，让cloud进入一种逐步实现的流程。还有构建命令可以帮助你打包和用NPM构建项目。同时在遇到一些你不知道如何修复的奇怪bug时进行排查。所以这是一个非常实用的软件包。尽管安装过程不是那么简单。我们需要先打开一个文件夹，先用UV net初始化一个Python项目，然后再用UV的super cloud，这样就会添加super cloud的包包，最后执行UV run Python super cloud install。然后它会引导你一步步完成安装过程，但一旦安装完成，会被安装在全局级别。所以你不需要反复进行这个操作，所所有的文件基本上都会保存在你用户级别的cloud设置中。如果我们打开它，实际上会在cloud的M文件中添加内容，这些内容会链接到包含更多细节的不同文件。在这个command文件夹里，你可以看到我们在这里定义的所有命令。所以这个简单的例子展示了仅仅通过命令功能，你就可以进行多么深度的自定义。同时cloud code还有很多非常实用的功能和快捷方式，是我一开始并不知道的。首先我可以输入斜杠resume，跳回到过去的对话历史，并在那儿继续对话。这有点类似于cursor，你可以选择过去的某个对话。但另一方面他们还引入了这个export命令。这这个功能可以让你复制与cloud code的整个对话历史。这样你就可以在cloud code RRRRENRR或其他任何编程IDE之间切换。因为你只需要粘贴对话历史，就不用担心cursor不知道之前做过什么。而且我经常会去cloud，因为那里有无限的token，可以用来做一些早期的探索。除此之外，另一个非常实用的功能是你可以双击退出，这样就可以将对话历史恢复到之前的某个时间点。你只需要点击它，就可以从那个时间点继续对话，这非常好。因为有时候code会出错，这样可以避免这些问题。唯一的缺点是如果你在cursor里，每当你回到之前的对话时，它会自动还原你所有的文件。但CLOCO并不会保留快照，所以你实际上需要使用一些外部包来进行快照还原。其中一个叫做c Candide，这是一个可以自动检测cod code对你文件所做所有更改，并允许你回滚的包。所以我可以输入CC undo和list，就会列出CLOUD code对你的文件所做的所有更改。你还可以使用c condo code来查看CLOUD code所做的具体更改，然后再确认后使用CCD do undo并选择你想要回退的更改。所以这个包可以很好的CLOUDO de配合使用。不过命令行可能不是预览这些更改最方便最直观的方式。还有一些更为用户友好的工具，比如OOO他会接受一个快照，并且你可以添加一些额外的说明来帮助记住这些更改内容。最后我还想向你展示将cloud code d连接到IMI care模型的最简单方法。如果你还不了解，KMME cr模型是一款新的开源编程模型，性能与cloud 3.5到cloud 4相当，但价格便宜了80%，所以如果你的额度用完了，这确实是一个很好的实验选择。最简单的设置方法就是打开终端，然后输入code，打开这个CRC文件。如果你和我一样用的是mac基本上只需要这样做就可以了。但如果你用的是windows，可能需要切换到bash，这样会打开一个类似这样的文件。这个文件基本上会控制你的终端行为。在这里我会定义Kimi的API密钥。别担心，我已经把这个密钥禁用了，所以你们用不了了。我还可以定义Kimi让它导出并把基础URL指向蒙上，使用这个API密钥并运行cloud。有了这个设置，我只需要在任意终端输入ki MI就可以了。这样就会用我在那边定义的特殊模型打开CLUD code。所以如果我在这里输入high，它实际上会和Kimi care模型进行对话。这就是我如何使用cloud code的一个简要概述。如果你想了解更多，可以加入AI build club。我们每周都会有分享会，讨论最新的工作流程和AI编码技巧，以及大语言模型的构建。还有我个人使用的所有详细规则、钩子和命令，你可以直接复制粘贴使用。在接下来的几周里，我们会更详细的解析CLOLLOD在幕后是如何运作的，并尝试从零开始重建gold code。这样我们就能学习到构建高效AI编码代理的最佳实践。我在下方描述中放了一个链接，方便你加入。希望你喜欢本期视频，谢谢大家，我们下次再见。